# 设计模式

## 一、工厂模式
### 1. 理解
创建一个模型，可以批量解决相同的问题，产生相同的效果

## 二、单体模式
### 1. 理解
单体模式是用来划分命名空间并将一批属性和方法组织在一起的对象
> 仅可被实例化一次

### 2. 实现一个弹窗
```js
let createWindow = (
  let div
  return function(content) {
    if(!div) {
      div = document.createElement('div')
      div.innerHtml = content
      div.style.display = 'none'
      document.body.appendChild(div)
    }
    return div
  }
)
document.getElementById("button").onclick = e => {
  let w = createWindow('我是一个弹窗')
  w.style.display = "block"
}
```

## 三、模块模式
### 1.实现
返回一个对象的匿名函数，在对象中存放暴露给外部的属性和方法
```js
let singleMode = (function() {
  let privetProperty = 1
  let publicProperty = 2
  let provateMethod = function() {}
  let publicMethod = function() {}
  return {
    publicProperty: publicProperty,
    publicMethod: publicMethod
  }
})
```

## 四、代理模式
主要优点是代码的拆分与解耦，单一职责原则，每个对象只负责自己的功能，逻辑清晰
### 1.代理模式实现图片预加载
```js
let myImg = (function() {
  let imgElement = document.createElement('img')
  document.body.appendChild(imgElement)
  return {
    setSrc(src) {
      imgElement.src = src
    }
  }
})()
let proxyImg = (function() {
  let img = new Image()
  let myImage = myImg //只执行一次myImg中的匿名函数
  img.onload = function() {
    myImage.setSrc(this.src)
  }
  return {
    setSrc(src) {
      myImage.setSrc('../loading.png')
      img.src = src
    }
  }
})()

proxyImg.setSrc('http://xxx.com/xxx.png')

```
## 六、发布订阅模式
观察者和被观察者是靠`中介者`联系的，参考Vue中的组件通信`on`和`emit`
```js
class Event{
  constructor() {
    this.callbacks = []
  }
  on(callback) {
    this.callbacks.push(callback)
  }
  emit() {
    this.callbacks.forEach(callback => {
      callback()
    })
  }
}

// 测试实例
let e = new Event()
e.on(() => {
  console.log(1)
})
e.on(() => {
  console.log(3)
})
e.on(() => {
  console.log(2)
})
e.emit()

// 结果： 1 3 2
```

## 七、 观察者模式
观察者和被观察者是强耦合的，会将`update`插入到被观察者中，参考Vue中的数据劫持
```js
class Subject{
  constructor(name) {
    this.name = name
  }
  setName(value) {
    let observer = new Observer()
    observer.update(this.name, value)
  }
}

class Observer{
  update(subject, value) {
    console.log(`${subject}的名字更新成${value}了`)
  }
}

// 测试实例
let sub = new Subject('张三')
sub.setName('李四')

// 结果： 张三的名字更新成李四了
```