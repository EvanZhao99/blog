## temp
- 时序图：更侧重对象直接消息传递在时间上的先后顺序
- 协作图：更侧重对象和角色交互的静态关系
- 组件图：
- 部署图
- 高内聚 低耦合
- 好的代码：1. 简洁； 2. 易于理解
  - 符合人类正常的习惯，会极大的减小理解成本，写代码要尽可能模拟现实中的流程

### 继承
- 优点： 实现代码复用
- 缺点：可读性变差（层级过深时），可维护性变差（修改父类会直接影响子类）

### 封装
- 优点：减少耦合，方便数据的权限管理


### 多态
- 重写父类的方法，实现特有的功能

### 开闭原则
开：类、模块、方法等应该具有扩展性。
闭：原有代码不应该被修改。添加新功能时不应该去修改源码

### 里氏替换原则
传父类的地方也可以传子类

### 依赖倒置原则
面向接口编程，依赖抽象而不依赖具体实现。

### 接口隔离原则
类似于职责单一

### 迪米特法则
初衷是低耦合

### 合成复用原则
- 从弱到强：依赖 > 关联> 聚合> 组合

# 设计模式
## 工厂模式
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
### 简单工厂模式
- what: 模拟工厂的流程,可以批量生产功能类似的对象
- why: 对创建对象的步骤进行封装，逻辑清晰，易于维护
- how: 通过条件语句判断类型，产出不同的对象
  ```js
    class Drink{
        constructor(type){
            this.type = type;
        }
        brew() {
            switch(this.type) {
                case 'tea': 
                    console.log('this is a cup of tea');
                    break;
                case 'coffee': 
                    console.log('this is a cup of coffee');
                    break;
                default:
                    console.log('this is a cup of water');
            }
        }
    }

    let tea = new Drink('tea')
    tea.brew();

    let coffee = new Drink('coffee');
    coffee.brew();

    let water = new Drink();
    water.brew();
  ```
### 工厂方法模式
- what: 
  - 又叫多态性工厂模式，主要是用来解决多态问题。
  - 本质上是创建了一个工厂接口，将实际创建对象的步骤延迟到了子类
  - 工厂方法模式是最典型的模板方法模式的应用（百度百科）
- why: 解决简单工厂模式的一些问题，符合“开闭原则”，适用于产品结果复杂的场景
- how: 在子类中重写方法
  ```js
  class Drink{
      brew() {
          throw new Error('必须实现brew方法')
      }
  }

  class Tea extends Drink{
      brew() {
          console.log('this is a cup of tea');
      }
  }

  class Coffee extends Drink{
      brew() {
          console.log('this is a cup of coffee');
      }
  }

  let tea = new Tea();
  tea.brew();

  let coffee = new Coffee();
  coffee.brew();
  ```


## 适配器模式
- what: 对不同环境进行包装，实现相同的api,用于解决兼容性问题
- why: 解决兼容问题，统一接口
- how: 对差异部分进行封装，放到同一个接口中，从而做到内部实现不同 api相同。