## temp
- 时序图：更侧重对象直接消息传递在时间上的先后顺序
- 协作图：更侧重对象和角色交互的静态关系
- 组件图：
- 部署图
- 高内聚 低耦合
- 好的代码：1. 简洁； 2. 易于理解
  - 符合人类正常的习惯，会极大的减小理解成本，写代码要尽可能模拟现实中的流程

### 继承
- 优点： 实现代码复用
- 缺点：可读性变差（层级过深时），可维护性变差（修改父类会直接影响子类）

### 封装
- 优点：减少耦合，方便数据的权限管理


### 多态
- 重写父类的方法，实现特有的功能

### 开闭原则
开：类、模块、方法等应该具有扩展性。
闭：原有代码不应该被修改。添加新功能时不应该去修改源码

### 里氏替换原则
传父类的地方也可以传子类

### 依赖倒置原则
面向接口编程，依赖抽象而不依赖具体实现。

### 接口隔离原则
类似于职责单一

### 迪米特法则
初衷是低耦合

### 合成复用原则
- 从弱到强：依赖 > 关联> 聚合> 组合

# 设计模式


## 适配器模式
- what: 对不同环境进行包装，实现相同的api,用于解决兼容性问题
- why: 解决兼容问题，统一接口
- how: 对差异部分进行封装，放到同一个接口中，从而做到内部实现不同 api相同。

## 单例模式
- what: 通过单例模式创建的类在当前进程中已有一个实例；
- how: 
  1. typescript例子
    ```typescript
    class Window{
      constructor() {
      }
      static getInstance() {
          if(!this.instance) {
            this.instance = new Window();
          }
          return this.instance;
      }
    }
    let w1 = Window.getInstance();
    let w2 = Window.getInstance();
    console.log(w1 === w2); // true
    ```
  2. es5 例子
    ```js
    let Window = (function() {
      let instance = null;
      return function() {
          if(!instance) {
            instance = this;
          }
          return instance
      }
    })();
    let w1 = new Window();
    let w2 = new Window();
    console.log(w1 === w2) // true
    ```
  3. 透明模式
    ```js
    let Window = (function() {
      let instance = null;
      return function() {
          if(!instance) {
            instance = this;
          }
          return instance
      }
    })();
    let w1 = new Window();
    let w2 = new Window();
    console.log(w1 === w2) // true
    ```
